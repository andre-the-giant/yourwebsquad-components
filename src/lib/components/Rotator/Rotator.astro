---
/*
Props:
- items?: (string | number | boolean | HTMLElement | null | undefined)[] — falls back to slot or defaults
- interval?: string — duration to hold each item (default "1.2s")
- speed?: string — transition speed between items (default "0.1s")
- size?: string — font size/line height (default "inherit")
- direction?: "up" | "down" (default "up")
- ariaLive?: "off" | "polite" | "assertive" (default "off")
- slot "default": optional list of <span> children used when items are not provided
Notes: spreads ...rest on outer <span>; clip path string expected like `m0,0.5 v0.5 h0.089 (...) -0.013 c0,-0.003,0 h-1`.
*/

const { items, interval, speed, size, direction, ariaLive, ...rest } = Astro.props;

const hasItemsArray = Array.isArray(items);
const hasSlot = Astro.slots.has("default");

const extractSlotItems = (rendered) => {
  if (!rendered) return [];
  const html = Array.isArray(rendered) ? rendered.join("") : String(rendered);
  const spans = html.match(/<span[\s\S]*?<\/span>/g);
  if (spans && spans.length) return spans;
  return html.trim().length ? [html] : [];
};

const renderedSlot = !hasItemsArray && hasSlot ? await Astro.slots.render("default") : "";
const slotItems = extractSlotItems(renderedSlot);
const isSlotMode = !hasItemsArray && slotItems.length > 0;

const defaultItems = ["Settings missing", "add items=[]"];
const itemsSource = hasItemsArray ? items : slotItems.length ? slotItems : defaultItems;
const normalizeItem = (item) => {
  if (item === null || item === undefined) return "";
  if (typeof item === "string") return item;
  if (typeof item === "number" || typeof item === "boolean") return String(item);
  return item;
};
const resolvedItems = (itemsSource.length ? itemsSource : defaultItems).map(normalizeItem);

const resolvedInterval = interval ?? "1.2s";
const resolvedSpeed = speed ?? "0.1s";
const resolvedDirection = direction ?? "up";
const resolvedAriaLive = ariaLive ?? "off";
const resolvedSize = size ?? "inherit";
const rotatorClassName = `rotator rotator--direction-${resolvedDirection}`;

const stepCount = resolvedItems.length;

const displayedItems =
  resolvedDirection === "down"
    ? [resolvedItems[resolvedItems.length - 1], ...resolvedItems].reverse()
    : [resolvedItems[resolvedItems.length - 1], ...resolvedItems];

const easing = makeFlickLinear(stepCount);

const styleVars = {
  "--rotator-interval": resolvedInterval,
  "--rotator-speed": resolvedSpeed,
  "--rotator-direction": "-1",
  "--rotator-steps": String(stepCount),
  "--rotator-ease": easing,
  "--rotator-font-size": resolvedSize
};

function makeFlickLinear(steps, { hold = 0.92, ramp = 0.07, settle = 0.01 } = {}) {
  const sum = hold + ramp + settle;
  hold /= sum;
  ramp /= sum;
  settle /= sum;

  if (!Number.isFinite(steps) || steps <= 1) return "linear";

  const segment = 100 / steps;
  const fmt = (n) => n.toFixed(3).replace(/\.?0+$/, "");

  const stops = [];
  for (let i = 0; i < steps; i++) {
    const start = i * segment;
    const end = (i + 1) * segment;
    const holdEnd = start + segment * hold;
    const rampEnd = end - segment * settle;

    const v0 = i / steps;
    const v1 = (i + 1) / steps;

    stops.push(
      `${fmt(v0)} ${fmt(start)}% ${fmt(holdEnd)}%`,
      `${fmt(v1)} ${fmt(rampEnd)}% ${fmt(end)}%`
    );
  }
  return `linear(${stops.join(", ")})`;
}
---

<span
  class={rotatorClassName}
  aria-live={resolvedAriaLive}
  role={resolvedAriaLive === "off" ? undefined : "status"}
  data-direction={resolvedDirection === "down" ? "down" : "up"}
  style={styleVars}
  {...rest}
>
  <span class="rotator__track">
    {
      displayedItems.map((item) =>
        isSlotMode && typeof item === "string" ? (
          <span class="rotator__item" set:html={item} />
        ) : (
          <span class="rotator__item">{item}</span>
        )
      )
    }
  </span>
</span>

<style>
  @keyframes rotator {
    0% {
      transform: translateY(0);
    }
    100% {
      transform: translateY(calc(var(--rotator-direction) * (1lh + 1rem) * var(--rotator-steps)));
    }
  }

  .rotator {
    height: 1lh;
    line-height: var(--rotator-font-size);
    font-size: var(--rotator-font-size);
    overflow: hidden;
    white-space: nowrap;
    display: inline-flex;
    align-items: baseline;
    vertical-align: baseline;
  }

  .rotator__track {
    display: flex;
    flex-direction: column;
    gap: 1rem;

    animation-name: rotator;
    animation-duration: calc(
      (var(--rotator-interval) + var(--rotator-speed)) * var(--rotator-steps)
    );
    animation-timing-function: var(--rotator-ease, linear);
    animation-iteration-count: infinite;
    will-change: transform;
  }

  .rotator__item {
    display: block;
    line-height: 1lh;
  }
  .rotator--direction-down .rotator__track {
    animation-direction: reverse;
  }
  @media (prefers-reduced-motion: reduce) {
    .rotator__track {
      animation: none;
    }
  }
</style>
