---
import { validateProps } from "../../utils/props.js";
import { makeStyleVars, mergeClasses } from "../../utils/style.js";
import Button from "../Button/Button.astro";
import FormInput from "../Form-Input/index.astro";
import FormTextarea from "../Form-Textarea/index.astro";
import FormSelect from "../Form-Select/index.astro";
import FormCheckbox from "../Form-Checkbox/index.astro";
import FormRadio from "../Form-Radio/index.astro";
import FormDate from "../Form-Date/index.astro";
import FormHidden from "../Form-Hidden/index.astro";
import FormUpload from "../Form-Upload/index.astro";
import FormFieldset from "../Form-Fieldset/index.astro";
import FormError from "../Form-Error/index.astro";
import FormHelp from "../Form-Help/index.astro";
import Alert from "../Alert/index.astro";
import { loadFormDefinition } from "../../forms/loader.js";
import { resolveLocalized } from "../../forms/schema.js";

/*
Props:
- formId?: string          // preferred: id of form in content collection
- form?: object            // pre-resolved form definition
- locale?: string          // locale key to resolve localized strings
- id?: string
- action?: string          // overrides form endpoint
- target?: string
- enctype?: string
- novalidate?: boolean       // defaults true to avoid native browser bubbles
- preventEnterSubmit?: boolean   // defaults true
- submitLabel?: string            // default "Send"
- submitVariant?: "solid" | "outline" | "ghost"
- submitSize?: "sm" | "md" | "lg"
- submitDisabled?: boolean
- submitClass?: string
- submitStyle?: string
- showReset?: boolean
- resetLabel?: string             // default "Reset"
- resetVariant?: "solid" | "outline" | "ghost"
- resetSize?: "sm" | "md" | "lg"
- resetDisabled?: boolean
- resetClass?: string
- resetStyle?: string
- validateOnSubmit?: boolean
- messages?: object         // optional runtime message overrides
- class?: string
- style?: string
*/

const schema = {
  formId: { type: "string" },
  form: { type: "object" },
  locale: { type: "string" },
  id: { type: "string" },
  class: { type: "string" },
  style: { type: "string" },
  action: { type: "string" },
  target: { type: "string" },
  enctype: { type: "string" },
  novalidate: { type: "boolean" },
  preventEnterSubmit: { type: "boolean" },
  submitLabel: { type: "string" },
  submitVariant: { type: "string" },
  submitSize: { type: "string" },
  submitDisabled: { type: "boolean" },
  submitClass: { type: "string" },
  submitStyle: { type: "string" },
  showReset: { type: "boolean" },
  resetLabel: { type: "string" },
  resetVariant: { type: "string" },
  resetSize: { type: "string" },
  resetDisabled: { type: "boolean" },
  resetClass: { type: "string" },
  resetStyle: { type: "string" },
  validateOnSubmit: { type: "boolean" },
  messages: { type: "object" }
};

const {
  formId,
  form,
  locale,
  id,
  class: className,
  style,
  action: actionProp,
  target,
  enctype,
  novalidate = true,
  preventEnterSubmit = true,
  submitLabel = "Send",
  submitVariant = "solid",
  submitSize = "md",
  submitDisabled = false,
  submitClass,
  submitStyle,
  showReset = true,
  resetLabel = "Reset",
  resetVariant = "outline",
  resetSize = "md",
  resetDisabled = false,
  resetClass,
  resetStyle,
  validateOnSubmit = true,
  messages,
  ...rest
} = validateProps(schema, Astro.props, { component: "Form" });

let normalizedForm = null;
if (formId || form) {
  normalizedForm = await loadFormDefinition({ formId, form });
}

const formHtmlId =
  id ??
  (normalizedForm?.id
    ? `form-${normalizedForm.id}`
    : `form-${Math.random().toString(36).slice(2, 9)}`);
const resolvedAction = actionProp ?? normalizedForm?.endpoint;
const resolvedTitle = normalizedForm ? resolveLocalized(normalizedForm.title, locale) : undefined;

const honeypotConfig = normalizedForm?.security?.honeypot;
const includeHoneypot = honeypotConfig?.enabled !== false && Boolean(honeypotConfig?.name);
const honeypotName = (honeypotConfig?.name || "middle_name").trim();
const honeypotLabel =
  resolveLocalized(honeypotConfig?.label, locale) || "Please leave this field blank";
const honeypotId = `${formHtmlId}-${honeypotName}`;

const fieldErrorMap = new Map();

const styleVars = {};
const resolvedStyle = makeStyleVars(styleVars, style);
const resolvedClass = mergeClasses("form", className);
const ariaMap = new Map();
const nextId = (prefix) => `${prefix}-${Math.random().toString(36).slice(2, 9)}`;

function registerField(name) {
  if (!ariaMap.has(name)) {
    ariaMap.set(name, { helpId: nextId(`help-${name}`), errorId: nextId(`error-${name}`) });
  }
  return ariaMap.get(name);
}

const formFields = normalizedForm?.fields ?? [];
const hasUploadField = formFields.some((field) => field.type === "upload");
const resolvedEnctype = enctype ?? (hasUploadField ? "multipart/form-data" : undefined);
const formMessageConfig =
  messages && typeof messages === "object"
    ? { ...(normalizedForm?.messages ?? {}), ...messages }
    : (normalizedForm?.messages ?? {});

const resolveMessage = (key, fallback) =>
  resolveLocalized(formMessageConfig?.[key], locale) || fallback;

const resolvedMessages = {
  alertClientTitle: resolveMessage("alertClientTitle", "Please fix the highlighted fields"),
  alertServerTitle: resolveMessage("alertServerTitle", "Something went wrong"),
  alertSuccessTitle: resolveMessage("alertSuccessTitle", "Success"),
  successMessage: resolveMessage("successMessage", "Thanks! Your message was sent."),
  submitLoadingLabel: resolveMessage("submitLoadingLabel", "Sending..."),
  submitLoadingAria: resolveMessage("submitLoadingAria", "Form is submitting, please wait."),
  networkError: resolveMessage("networkError", "Network error. Please try again."),
  fallbackValidationIssue: resolveMessage("fallbackValidationIssue", "is required or invalid."),
  fieldErrorSeparator: resolveMessage("fieldErrorSeparator", " - "),
  validationRequired: resolveMessage("validationRequired", "This field is required."),
  validationInvalid: resolveMessage("validationInvalid", "Invalid value."),
  validationInvalidEmail: resolveMessage("validationInvalidEmail", "Please enter a valid email."),
  validationTooLong: resolveMessage("validationTooLong", "Too long."),
  validationTooShort: resolveMessage("validationTooShort", "Too short."),
  validationInvalidFormat: resolveMessage("validationInvalidFormat", "Invalid format."),
  validationInvalidSelection: resolveMessage("validationInvalidSelection", "Invalid selection."),
  uploadFilesSelectedText: resolveMessage("uploadFilesSelectedText", "{count} files selected"),
  uploadPreviewUnavailableText: resolveMessage(
    "uploadPreviewUnavailableText",
    "Preview unavailable"
  ),
  uploadOnlyOneFile: resolveMessage("uploadOnlyOneFile", "Only one file is allowed."),
  uploadTooManyFiles: resolveMessage("uploadTooManyFiles", "Please select at most {max} files."),
  uploadFileTooLarge: resolveMessage("uploadFileTooLarge", "Each file must be {max}MB or smaller."),
  uploadBlockedFileType: resolveMessage("uploadBlockedFileType", "Blocked file type: {name}"),
  uploadBlockedFileContentType: resolveMessage(
    "uploadBlockedFileContentType",
    "Blocked file content type: {name}"
  ),
  uploadOnlyImageFiles: resolveMessage("uploadOnlyImageFiles", "Only image files are allowed."),
  uploadInvalidFileType: resolveMessage("uploadInvalidFileType", "Invalid file type.")
};
---

<div
  class="form-wrapper"
  data-form-wrapper
  data-msg-network-error={resolvedMessages.networkError}
  data-msg-fallback-validation={resolvedMessages.fallbackValidationIssue}
  data-msg-field-separator={resolvedMessages.fieldErrorSeparator}
  data-msg-submit-loading-label={resolvedMessages.submitLoadingLabel}
  data-msg-submit-loading-aria={resolvedMessages.submitLoadingAria}
  data-msg-required={resolvedMessages.validationRequired}
  data-msg-invalid={resolvedMessages.validationInvalid}
  data-msg-invalid-email={resolvedMessages.validationInvalidEmail}
  data-msg-too-long={resolvedMessages.validationTooLong}
  data-msg-too-short={resolvedMessages.validationTooShort}
  data-msg-invalid-format={resolvedMessages.validationInvalidFormat}
  data-msg-invalid-selection={resolvedMessages.validationInvalidSelection}
  data-msg-upload-only-one={resolvedMessages.uploadOnlyOneFile}
  data-msg-upload-too-many={resolvedMessages.uploadTooManyFiles}
  data-msg-upload-too-large={resolvedMessages.uploadFileTooLarge}
  data-msg-upload-blocked-type={resolvedMessages.uploadBlockedFileType}
  data-msg-upload-blocked-content={resolvedMessages.uploadBlockedFileContentType}
  data-msg-upload-images-only={resolvedMessages.uploadOnlyImageFiles}
  data-msg-upload-invalid-type={resolvedMessages.uploadInvalidFileType}
>
  <div class="form-alerts">
    <Alert
      type="warning"
      tone="soft"
      title={resolvedMessages.alertClientTitle}
      class="form-alert is-hidden"
      data-alert="client"
      hidden
    >
      <ul data-alert-list="client"></ul>
    </Alert>

    <Alert
      type="error"
      tone="soft"
      title={resolvedMessages.alertServerTitle}
      class="form-alert is-hidden"
      data-alert="server"
      hidden
    >
      <ul data-alert-list="server">
        {null}
      </ul>
    </Alert>

    <Alert
      type="success"
      tone="soft"
      title={resolvedMessages.alertSuccessTitle}
      class="form-alert is-hidden"
      data-alert="success"
      hidden
    >
      <p data-alert-message="success">{resolvedMessages.successMessage}</p>
    </Alert>
  </div>

  <form
    id={formHtmlId}
    class={resolvedClass}
    action={resolvedAction}
    method="post"
    target={target}
    enctype={resolvedEnctype}
    novalidate={novalidate ? true : undefined}
    data-validate={validateOnSubmit ? "true" : "false"}
    data-prevent-enter={preventEnterSubmit ? "true" : undefined}
    style={resolvedStyle || undefined}
    {...rest}
  >
    {resolvedTitle ? <h3 class="form-title">{resolvedTitle}</h3> : null}

    <div class="form-body">
      {
        includeHoneypot ? (
          <div class="form-honeypot" aria-hidden="true">
            <FormInput
              id={honeypotId}
              name={honeypotName}
              label={honeypotLabel}
              ariaLabel={honeypotLabel}
              tabindex="-1"
            />
          </div>
        ) : null
      }
      {
        formFields.length > 0 ? (
          formFields.map((field) => {
            const help = registerField(field.name);
            const shared = {
              name: field.name,
              required: field.required,
              ariaDescribedBy: [help.helpId, help.errorId].join(" ").trim() || undefined,
              ariaInvalid: fieldErrorMap.has(field.name) ? true : undefined
            };

            const localizedLabel = resolveLocalized(field.label, locale);
            const localizedPlaceholder = resolveLocalized(field.placeholder, locale);
            const localizedNoFileText = resolveLocalized(field.noFileText, locale);
            const localizedBrowseLabel = resolveLocalized(field.browseLabel, locale);
            const localizedRemoveLabel = resolveLocalized(field.removeLabel, locale);
            const validationAttrs = {
              maxLength: field.maxLength,
              minLength: field.minLength,
              pattern: field.pattern
            };

            if (
              field.type === "text" ||
              field.type === "email" ||
              field.type === "tel" ||
              field.type === "number"
            ) {
              return (
                <div class="form-field-block">
                  <FormInput
                    label={localizedLabel}
                    type={field.type === "text" ? "text" : field.type}
                    placeholder={localizedPlaceholder}
                    value={field.defaultValue}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                    {...validationAttrs}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            if (field.type === "textarea") {
              return (
                <div class="form-field-block">
                  <FormTextarea
                    label={localizedLabel}
                    placeholder={localizedPlaceholder}
                    value={field.defaultValue}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                    {...validationAttrs}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            if (field.type === "select") {
              return (
                <div class="form-field-block">
                  <FormSelect
                    label={localizedLabel}
                    options={(field.options || []).map((opt) => ({
                      ...opt,
                      label: resolveLocalized(opt.label, locale)
                    }))}
                    placeholder={localizedPlaceholder}
                    value={field.defaultValue}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            if (field.type === "checkbox") {
              return (
                <div class="form-field-block">
                  <FormCheckbox
                    label={localizedLabel}
                    checked={Boolean(field.defaultValue)}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            if (field.type === "radio") {
              const options = field.options || [];
              const groupId = nextId(`fieldset-${field.name}`);
              return (
                <FormFieldset
                  id={groupId}
                  legend={localizedLabel}
                  required={field.required}
                  helpId={help.helpId}
                  errorId={help.errorId}
                >
                  <div class="form-radio-group">
                    {options.map((opt, idx) => {
                      const optId = `${field.name}-${idx}`;
                      return (
                        <FormRadio
                          id={optId}
                          name={field.name}
                          value={opt.value}
                          label={resolveLocalized(opt.label, locale)}
                          checked={field.defaultValue === opt.value}
                          required={field.required}
                          ariaDescribedBy={
                            [help.helpId, help.errorId].join(" ").trim() || undefined
                          }
                        />
                      );
                    })}
                  </div>
                  <FormHelp slot="help" id={help.helpId} />
                  <FormError slot="error" id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </FormFieldset>
              );
            }

            if (field.type === "date") {
              return (
                <div class="form-field-block">
                  <FormDate
                    label={localizedLabel}
                    value={field.defaultValue}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                    {...validationAttrs}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            if (field.type === "hidden") {
              return <FormHidden name={field.name} value={field.defaultValue} />;
            }

            if (field.type === "upload") {
              return (
                <div class="form-field-block">
                  <FormUpload
                    label={localizedLabel}
                    accept={field.accept || "image/*"}
                    imagesOnly={field.imagesOnly !== false}
                    multiple={Boolean(field.multiple)}
                    maxFiles={field.maxFiles}
                    maxFileSizeMb={field.maxFileSizeMb}
                    noFileText={localizedNoFileText}
                    browseLabel={localizedBrowseLabel}
                    removeLabel={localizedRemoveLabel}
                    filesSelectedText={
                      resolveLocalized(field.filesSelectedText, locale) ||
                      resolvedMessages.uploadFilesSelectedText
                    }
                    previewUnavailableText={
                      resolveLocalized(field.previewUnavailableText, locale) ||
                      resolvedMessages.uploadPreviewUnavailableText
                    }
                    messages={{
                      onlyOneFile: resolvedMessages.uploadOnlyOneFile,
                      tooManyFiles: resolvedMessages.uploadTooManyFiles,
                      fileTooLarge: resolvedMessages.uploadFileTooLarge,
                      blockedFileType: resolvedMessages.uploadBlockedFileType,
                      blockedFileContentType: resolvedMessages.uploadBlockedFileContentType,
                      onlyImageFiles: resolvedMessages.uploadOnlyImageFiles,
                      invalidFileType: resolvedMessages.uploadInvalidFileType
                    }}
                    helpId={help.helpId}
                    errorId={help.errorId}
                    {...shared}
                  />
                  <FormHelp id={help.helpId} />
                  <FormError id={help.errorId} data-field-error={field.name}>
                    {fieldErrorMap.get(field.name)?.join(" ")}
                  </FormError>
                </div>
              );
            }

            return null;
          })
        ) : (
          <slot />
        )
      }
    </div>

    <div class="form-actions">
      {
        showReset ? (
          <slot name="reset">
            <Button
              type="reset"
              variant={resetVariant}
              size={resetSize}
              disabled={resetDisabled}
              class={resetClass}
              style={resetStyle}
            >
              {resetLabel}
            </Button>
          </slot>
        ) : null
      }

      <slot name="submit">
        <Button
          type="submit"
          variant={submitVariant}
          size={submitSize}
          disabled={submitDisabled}
          class={submitClass}
          style={submitStyle}
          data-form-submit-default
        >
          <span data-form-submit-label>{submitLabel}</span>
          <span class="form-submit-spinner" data-form-submit-spinner aria-hidden="true" hidden></span>
          <span data-form-submit-loading-label hidden>{resolvedMessages.submitLoadingLabel}</span>
        </Button>
      </slot>
    </div>
    <p class="form-visually-hidden" data-form-loading-status aria-live="polite"></p>
  </form>
</div>

<script is:inline>
  document.querySelectorAll("[data-form-wrapper]").forEach((wrapper) => {
    const form = wrapper.querySelector("form");
    if (!(form instanceof HTMLFormElement)) return;
    if (form.dataset.validationBound === "true") return;
    form.dataset.validationBound = "true";

    const action = form.getAttribute("action");
    const method = (form.getAttribute("method") || "post").toUpperCase();
    const enctype = form.getAttribute("enctype") || "application/x-www-form-urlencoded";
    const shouldValidate = form.dataset.validate !== "false";

    const alertClient = wrapper.querySelector('[data-alert="client"]');
    const alertServer = wrapper.querySelector('[data-alert="server"]');
    const alertSuccess = wrapper.querySelector('[data-alert="success"]');
    const listClient = wrapper.querySelector('[data-alert-list="client"]');
    const listServer = wrapper.querySelector('[data-alert-list="server"]');
    const successMessage = wrapper.querySelector('[data-alert-message="success"]');
    const fieldErrorEls = wrapper.querySelectorAll("[data-field-error]");
    const loadingStatusEl = form.querySelector("[data-form-loading-status]");

    const readMsg = (key, fallback) => {
      const value = wrapper.dataset[key];
      return typeof value === "string" && value.trim() ? value.trim() : fallback;
    };

    const messages = {
      submitLoadingLabel: readMsg("msgSubmitLoadingLabel", "Sending..."),
      submitLoadingAria: readMsg("msgSubmitLoadingAria", "Form is submitting, please wait."),
      networkError: readMsg("msgNetworkError", "Network error. Please try again."),
      fallbackValidationIssue: readMsg("msgFallbackValidation", "is required or invalid."),
      fieldErrorSeparator: readMsg("msgFieldSeparator", " - "),
      validationRequired: readMsg("msgRequired", "This field is required."),
      validationInvalid: readMsg("msgInvalid", "Invalid value."),
      validationInvalidEmail: readMsg("msgInvalidEmail", "Please enter a valid email."),
      validationTooLong: readMsg("msgTooLong", "Too long."),
      validationTooShort: readMsg("msgTooShort", "Too short."),
      validationInvalidFormat: readMsg("msgInvalidFormat", "Invalid format."),
      validationInvalidSelection: readMsg("msgInvalidSelection", "Invalid selection."),
      uploadOnlyOneFile: readMsg("msgUploadOnlyOne", "Only one file is allowed."),
      uploadTooManyFiles: readMsg("msgUploadTooMany", "Please select at most {max} files."),
      uploadFileTooLarge: readMsg("msgUploadTooLarge", "Each file must be {max}MB or smaller."),
      uploadBlockedFileType: readMsg("msgUploadBlockedType", "Blocked file type: {name}"),
      uploadBlockedFileContentType: readMsg(
        "msgUploadBlockedContent",
        "Blocked file content type: {name}"
      ),
      uploadOnlyImageFiles: readMsg("msgUploadImagesOnly", "Only image files are allowed."),
      uploadInvalidFileType: readMsg("msgUploadInvalidType", "Invalid file type.")
    };
    let isLoading = false;
    let loadingDisabledSnapshot = new WeakMap();
    let loadingSubmitSnapshot = new WeakMap();

    function setSubmitLoadingState(next) {
      const submitControls = form.querySelectorAll('button[type="submit"], input[type="submit"]');
      if (next) {
        loadingSubmitSnapshot = new WeakMap();
      }

      submitControls.forEach((control) => {
        if (!(control instanceof HTMLButtonElement || control instanceof HTMLInputElement)) return;

        if (next) {
          loadingSubmitSnapshot.set(control, {
            ariaLabel: control.getAttribute("aria-label"),
            value: control instanceof HTMLInputElement ? control.value : null,
            html: control instanceof HTMLButtonElement ? control.innerHTML : null
          });

          control.setAttribute("aria-label", messages.submitLoadingAria);

          if (control instanceof HTMLButtonElement) {
            const labelEl = control.querySelector("[data-form-submit-label]");
            const loadingLabelEl = control.querySelector("[data-form-submit-loading-label]");
            const spinnerEl = control.querySelector("[data-form-submit-spinner]");
            const hasManagedSubmitUi = Boolean(labelEl && loadingLabelEl && spinnerEl);

            if (hasManagedSubmitUi) {
              labelEl.setAttribute("hidden", "true");
              loadingLabelEl.removeAttribute("hidden");
              spinnerEl.removeAttribute("hidden");
              control.classList.add("is-loading");
            } else {
              control.textContent = messages.submitLoadingLabel;
            }
            return;
          }

          control.value = messages.submitLoadingLabel;
          return;
        }

        const snapshot = loadingSubmitSnapshot.get(control);
        if (!snapshot) return;

        if (control instanceof HTMLButtonElement) {
          const labelEl = control.querySelector("[data-form-submit-label]");
          const loadingLabelEl = control.querySelector("[data-form-submit-loading-label]");
          const spinnerEl = control.querySelector("[data-form-submit-spinner]");
          const hasManagedSubmitUi = Boolean(labelEl && loadingLabelEl && spinnerEl);

          if (hasManagedSubmitUi) {
            labelEl.removeAttribute("hidden");
            loadingLabelEl.setAttribute("hidden", "true");
            spinnerEl.setAttribute("hidden", "true");
            control.classList.remove("is-loading");
          } else if (typeof snapshot.html === "string") {
            control.innerHTML = snapshot.html;
          }
        } else if (typeof snapshot.value === "string") {
          control.value = snapshot.value;
        }

        if (typeof snapshot.ariaLabel === "string") {
          control.setAttribute("aria-label", snapshot.ariaLabel);
        } else {
          control.removeAttribute("aria-label");
        }
      });

      if (!next) {
        loadingSubmitSnapshot = new WeakMap();
      }
    }

    function setLoadingState(nextState) {
      const next = Boolean(nextState);
      if (isLoading === next) return;
      isLoading = next;

      form.dataset.loading = isLoading ? "true" : "false";
      form.setAttribute("aria-busy", isLoading ? "true" : "false");
      form.classList.toggle("is-loading", isLoading);
      if (loadingStatusEl instanceof HTMLElement) {
        loadingStatusEl.textContent = isLoading ? messages.submitLoadingAria : "";
      }
      setSubmitLoadingState(isLoading);

      const controls = form.querySelectorAll("button, input, select, textarea, fieldset");
      if (isLoading) {
        loadingDisabledSnapshot = new WeakMap();
        controls.forEach((control) => {
          if (!("disabled" in control)) return;
          loadingDisabledSnapshot.set(control, Boolean(control.disabled));
          control.disabled = true;
        });
        return;
      }

      controls.forEach((control) => {
        if (!("disabled" in control)) return;
        const wasDisabled = loadingDisabledSnapshot.get(control);
        if (typeof wasDisabled === "boolean") {
          control.disabled = wasDisabled;
        } else {
          control.disabled = false;
        }
      });
      loadingDisabledSnapshot = new WeakMap();
    }

    function normalizeFieldName(name) {
      return typeof name === "string" ? name.replace(/\[\]$/, "") : name;
    }

    function formatTemplate(template, values = {}) {
      return String(template || "")
        .replace(/\{([a-zA-Z0-9_]+)\}/g, (_, token) => {
          const value = values[token];
          return value === undefined || value === null ? "" : String(value);
        })
        .replace(/\s{2,}/g, " ")
        .trim();
    }

    function normalize(value) {
      return Array.isArray(value) ? value : value ? [value] : [];
    }

    function getInputByName(name) {
      const normalized = normalizeFieldName(name);
      if (!normalized) return null;
      const inputs = form.querySelectorAll("input[name], select[name], textarea[name]");
      for (const input of inputs) {
        const candidate = normalizeFieldName(input.getAttribute("name"));
        if (candidate === normalized) return input;
      }
      return null;
    }

    function getFieldLabel(el) {
      const id = el.id;
      const cleanName = normalizeFieldName(el.getAttribute("name"));
      let label = "";
      if (id) {
        const labels = form.querySelectorAll("label[for]");
        for (const current of labels) {
          if (current.getAttribute("for") === id) {
            label = current.textContent?.trim() || "";
            break;
          }
        }
      }
      return label || el.getAttribute("aria-label") || cleanName || id || "This field";
    }

    function getFieldLabelByName(name) {
      const input = getInputByName(name);
      return input ? getFieldLabel(input) : normalizeFieldName(name) || "This field";
    }

    function formatFieldIssue(fieldName, issue) {
      const label = getFieldLabelByName(fieldName);
      return `${label}${messages.fieldErrorSeparator}${issue}`;
    }

    function hideAlert(alertEl) {
      if (!alertEl) return;
      alertEl.classList.add("is-hidden");
      alertEl.setAttribute("hidden", "true");
    }

    function showAlert(alertEl, { focus = false } = {}) {
      if (!alertEl) return;
      alertEl.classList.remove("is-hidden");
      alertEl.removeAttribute("hidden");
      alertEl.scrollIntoView({ behavior: "smooth", block: "center" });
      if (focus && alertEl instanceof HTMLElement) {
        alertEl.setAttribute("tabindex", "-1");
        requestAnimationFrame(() => {
          alertEl.focus({ preventScroll: true });
        });
      }
    }

    function localizeServerIssue(fieldName, issue) {
      const raw = String(issue || "").trim();
      if (!raw) return messages.validationInvalid;

      const uploadInput = getInputByName(fieldName);
      const maxFiles = Number(uploadInput?.dataset.maxFiles || "");
      const maxFileSizeMb = Number(uploadInput?.dataset.maxFileSizeMb || "");
      const maxFilesValue = Number.isFinite(maxFiles) && maxFiles > 0 ? maxFiles : "";
      const maxFileSizeValue =
        Number.isFinite(maxFileSizeMb) && maxFileSizeMb > 0 ? maxFileSizeMb : "";
      const formatWithoutDanglingPunctuation = (template, values, fallback) => {
        const formatted = formatTemplate(template, values)
          .replace(/[:;,.\-]\s*$/, "")
          .trim();
        return formatted || fallback;
      };

      if (raw === "This field is required.") return messages.validationRequired;
      if (raw === "Invalid value.") return messages.validationInvalid;
      if (raw === "Please enter a valid email.") return messages.validationInvalidEmail;
      if (raw === "Too long.") return messages.validationTooLong;
      if (raw === "Too short.") return messages.validationTooShort;
      if (raw === "Invalid format.") return messages.validationInvalidFormat;
      if (raw === "Invalid selection.") return messages.validationInvalidSelection;
      if (raw === "Only one file is allowed.") return messages.uploadOnlyOneFile;
      if (raw === "Too many files uploaded.") {
        return formatTemplate(messages.uploadTooManyFiles, { max: maxFilesValue });
      }
      if (raw === "File is too large.") {
        return formatTemplate(messages.uploadFileTooLarge, { max: maxFileSizeValue });
      }
      if (raw === "Blocked file extension.") {
        return formatWithoutDanglingPunctuation(
          messages.uploadBlockedFileType,
          { name: "" },
          messages.uploadInvalidFileType
        );
      }
      if (raw === "Blocked file content type.") {
        return formatWithoutDanglingPunctuation(
          messages.uploadBlockedFileContentType,
          { name: "" },
          messages.uploadInvalidFileType
        );
      }
      if (raw === "Only image files are allowed.") return messages.uploadOnlyImageFiles;
      if (raw === "Invalid file type.") return messages.uploadInvalidFileType;
      return raw;
    }

    function messagesForField(map, name) {
      const direct = map[name];
      if (direct !== undefined) return normalize(direct);
      const normalized = normalizeFieldName(name);
      if (normalized !== undefined && map[normalized] !== undefined) {
        return normalize(map[normalized]);
      }
      if (normalized !== undefined && map[`${normalized}[]`] !== undefined) {
        return normalize(map[`${normalized}[]`]);
      }
      return [];
    }

    function setFieldErrors(map = {}) {
      fieldErrorEls.forEach((el) => {
        const field = el.dataset.fieldError;
        const localized = messagesForField(map, field).map((msg) =>
          localizeServerIssue(field, msg)
        );
        el.textContent = localized.join(" ");
        if (localized.length === 0) {
          el.setAttribute("hidden", "true");
        } else {
          el.removeAttribute("hidden");
        }
      });

      const inputs = form.querySelectorAll("input[name], select[name], textarea[name]");
      inputs.forEach((input) => {
        const invalid = messagesForField(map, input.name).length > 0;
        if (invalid) {
          input.setAttribute("aria-invalid", "true");
        } else {
          input.removeAttribute("aria-invalid");
        }
      });
    }

    const blockedExtensions = new Set([
      ".php",
      ".phtml",
      ".php3",
      ".php4",
      ".php5",
      ".phar",
      ".pl",
      ".py",
      ".rb",
      ".cgi",
      ".asp",
      ".aspx",
      ".jsp",
      ".js",
      ".mjs",
      ".cjs",
      ".sh",
      ".bash",
      ".zsh",
      ".ps1",
      ".bat",
      ".cmd",
      ".com",
      ".exe",
      ".msi",
      ".dll",
      ".so",
      ".dylib",
      ".jar",
      ".vbs",
      ".wsf",
      ".hta",
      ".html",
      ".htm",
      ".xhtml",
      ".shtml",
      ".css",
      ".scss",
      ".sass",
      ".less",
      ".xml",
      ".svg"
    ]);

    const imageExtensions = new Set([
      ".jpg",
      ".jpeg",
      ".png",
      ".webp",
      ".gif",
      ".bmp",
      ".tiff",
      ".tif",
      ".avif",
      ".heif",
      ".heic"
    ]);

    function getExtension(name) {
      const value = String(name || "").toLowerCase();
      const dot = value.lastIndexOf(".");
      return dot >= 0 ? value.slice(dot) : "";
    }

    function isDangerousMime(type) {
      const mime = String(type || "")
        .trim()
        .toLowerCase();
      if (!mime) return false;
      return (
        /^text\//i.test(mime) ||
        /^application\/(javascript|x-javascript|ecmascript|x-httpd-php|x-php|x-sh|x-msdownload|x-dosexec|x-executable|x-bat|x-csh)/i.test(
          mime
        ) ||
        /^application\/html/i.test(mime) ||
        /^image\/svg\+xml/i.test(mime)
      );
    }

    function isImageFile(file) {
      const mime = String(file?.type || "").toLowerCase();
      if (mime.startsWith("image/") && mime !== "image/svg+xml") return true;
      const ext = getExtension(file?.name || "");
      return imageExtensions.has(ext);
    }

    function matchesAccept(file, accept) {
      const tokens = String(accept || "")
        .split(",")
        .map((token) => token.trim().toLowerCase())
        .filter(Boolean);
      if (!tokens.length) return true;

      const mime = String(file?.type || "").toLowerCase();
      const ext = getExtension(file?.name || "");

      return tokens.some((token) => {
        if (token.startsWith(".")) {
          return ext === token;
        }
        if (token.endsWith("/*")) {
          const prefix = token.slice(0, -1);
          if (mime && mime.startsWith(prefix)) return true;
          if (prefix === "image/" && imageExtensions.has(ext)) return true;
          return false;
        }
        if (!mime) return false;
        return mime === token;
      });
    }

    function validateFileInput(input) {
      if (!(input instanceof HTMLInputElement) || input.type !== "file") return "";
      const files = Array.from(input.files || []);
      if (!input.multiple && files.length > 1) {
        return messages.uploadOnlyOneFile;
      }
      const maxFiles = Number(input.dataset.maxFiles || "");
      const maxFileSizeMb = Number(input.dataset.maxFileSizeMb || "");
      const imagesOnly = input.dataset.imagesOnly !== "false";

      if (Number.isFinite(maxFiles) && maxFiles > 0 && files.length > maxFiles) {
        return formatTemplate(messages.uploadTooManyFiles, { max: maxFiles, count: files.length });
      }

      if (Number.isFinite(maxFileSizeMb) && maxFileSizeMb > 0) {
        const maxBytes = maxFileSizeMb * 1024 * 1024;
        const tooLarge = files.find((file) => file.size > maxBytes);
        if (tooLarge) {
          return formatTemplate(messages.uploadFileTooLarge, {
            max: maxFileSizeMb,
            name: tooLarge.name
          });
        }
      }

      const blocked = files.find((file) => blockedExtensions.has(getExtension(file.name)));
      if (blocked) {
        return formatTemplate(messages.uploadBlockedFileType, { name: blocked.name });
      }

      const dangerousMime = files.find((file) => isDangerousMime(file.type));
      if (dangerousMime) {
        return formatTemplate(messages.uploadBlockedFileContentType, { name: dangerousMime.name });
      }

      if (imagesOnly) {
        const nonImage = files.find((file) => !isImageFile(file));
        if (nonImage) {
          return messages.uploadOnlyImageFiles;
        }
      }

      const accept = String(input.getAttribute("accept") || "").trim();
      if (accept) {
        const invalidType = files.find((file) => !matchesAccept(file, accept));
        if (invalidType) {
          return formatTemplate(messages.uploadInvalidFileType, { name: invalidType.name });
        }
      }

      return "";
    }

    function focusFieldByName(name) {
      const input = getInputByName(name);
      if (!(input instanceof HTMLElement)) return;
      input.focus({ preventScroll: true });
      input.scrollIntoView({ behavior: "smooth", block: "center" });
    }

    function listToUl(listEl, entries) {
      if (!listEl) return;
      listEl.innerHTML = "";
      entries.forEach((entry) => {
        const payload =
          typeof entry === "string"
            ? { text: entry, field: undefined }
            : { ...entry, text: entry?.text || "" };
        const li = document.createElement("li");
        const fieldName = normalizeFieldName(payload.field);
        const hasField = Boolean(fieldName && getInputByName(fieldName));
        if (hasField) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "form-alert-link";
          button.textContent = payload.text;
          button.addEventListener("click", () => focusFieldByName(fieldName));
          li.appendChild(button);
        } else {
          li.textContent = payload.text;
        }
        listEl.appendChild(li);
      });
    }

    function getClientValidationIssue(el) {
      if (!(el instanceof HTMLElement) || !("validity" in el)) {
        return messages.fallbackValidationIssue;
      }
      const validity = el.validity;
      if (!validity) return messages.fallbackValidationIssue;

      if (validity.customError) {
        return el.validationMessage?.trim() || messages.validationInvalid;
      }
      if (validity.valueMissing) return messages.validationRequired;
      if (validity.typeMismatch) {
        if (el instanceof HTMLInputElement && el.type === "email") {
          return messages.validationInvalidEmail;
        }
        return messages.validationInvalid;
      }
      if (validity.tooLong) return messages.validationTooLong;
      if (validity.tooShort) return messages.validationTooShort;
      if (validity.patternMismatch) return messages.validationInvalidFormat;
      if (
        validity.badInput ||
        validity.rangeOverflow ||
        validity.rangeUnderflow ||
        validity.stepMismatch
      ) {
        return messages.validationInvalid;
      }
      return el.validationMessage?.trim() || messages.fallbackValidationIssue;
    }

    document.querySelectorAll("form[data-prevent-enter]").forEach((f) => {
      if (!(f instanceof HTMLFormElement)) return;
      if (f.dataset.enterBound === "true") return;
      f.dataset.enterBound = "true";
      f.addEventListener("keydown", (event) => {
        if (event.key !== "Enter") return;
        const target = event.target;
        if (!target) return;
        const tag = target.tagName?.toLowerCase();
        const type = target.getAttribute?.("type");
        const allow =
          tag === "textarea" ||
          tag === "select" ||
          type === "submit" ||
          type === "button" ||
          type === "reset";
        if (allow) return;
        event.preventDefault();
      });
    });

    form.addEventListener("submit", async (event) => {
      if (!shouldValidate) return;
      if (isLoading) {
        event.preventDefault();
        return;
      }

      const fileInputs = Array.from(form.querySelectorAll('input[type="file"]'));
      fileInputs.forEach((input) => {
        const msg = validateFileInput(input);
        input.setCustomValidity(msg);
      });

      const invalidFields = Array.from(form.querySelectorAll("input, select, textarea")).filter(
        (el) => !el.checkValidity()
      );

      if (invalidFields.length) {
        event.preventDefault();
        setFieldErrors({});
        const entries = invalidFields.map((el) => {
          const fieldName = normalizeFieldName(el.getAttribute("name")) || undefined;
          const label = getFieldLabel(el);
          const issue = getClientValidationIssue(el);
          return {
            field: fieldName,
            text: `${label}${messages.fieldErrorSeparator}${issue}`
          };
        });
        hideAlert(alertServer);
        listToUl(listClient, entries);
        showAlert(alertClient, { focus: true });
        const first = invalidFields[0];
        if (first instanceof HTMLElement) {
          first.scrollIntoView({ behavior: "smooth", block: "center" });
        }
        return;
      }

      if (action) {
        event.preventDefault();
        hideAlert(alertClient);
        hideAlert(alertServer);
        setLoadingState(true);
        try {
          const formData = new FormData(form);
          const opts = { method, headers: {} };
          let res;

          if (method === "GET") {
            const params = new URLSearchParams(formData);
            const sep = action.includes("?") ? "&" : "?";
            res = await fetch(action + sep + params.toString(), opts);
          } else {
            if (enctype === "application/json") {
              const hasFiles = Array.from(formData.values()).some(
                (value) => value instanceof File && value.size > 0
              );

              if (!hasFiles) {
                opts.headers["Content-Type"] = "application/json";
                opts.body = JSON.stringify(Object.fromEntries(formData));
              } else {
                opts.body = formData;
              }
            } else {
              opts.body = formData;
            }

            res = await fetch(action, opts);
          }

          await handleResponse(res);
        } catch (err) {
          showError(err);
        } finally {
          setLoadingState(false);
        }
      }
    });

    async function handleResponse(res) {
      let payload = null;
      const text = await res.text();
      try {
        payload = text ? JSON.parse(text) : null;
      } catch (_) {
        payload = null;
      }

      const fieldErrors = payload && typeof payload.errors === "object" ? payload.errors : {};
      const successFallback = successMessage?.textContent?.trim() || "";
      const globalMsg =
        (payload && (payload.message || payload.detail || payload.error)) ||
        (res.ok ? successFallback : res.statusText);

      setFieldErrors(fieldErrors || {});

      if (res.ok && payload?.ok !== false) {
        if (successMessage && globalMsg) {
          successMessage.textContent = globalMsg;
        }
        hideAlert(alertClient);
        hideAlert(alertServer);
        showAlert(alertSuccess, { focus: true });
        form.classList.add("is-hidden");
        form.setAttribute("hidden", "true");
        return;
      }

      const entries = [];
      if (globalMsg) entries.push({ text: globalMsg });
      Object.entries(fieldErrors || {}).forEach(([field, value]) => {
        const arr = normalize(value);
        arr.forEach((msg) => {
          const normalizedField = normalizeFieldName(field) || field;
          const issue = localizeServerIssue(normalizedField, msg || field);
          entries.push({
            field: normalizedField,
            text: formatFieldIssue(normalizedField, issue)
          });
        });
      });

      listToUl(listServer, entries);
      hideAlert(alertClient);
      showAlert(alertServer, { focus: true });
    }

    function showError(err) {
      setFieldErrors({});
      listToUl(listServer, [{ text: err?.message || messages.networkError }]);
      hideAlert(alertClient);
      showAlert(alertServer, { focus: true });
    }
  });
</script>

<style>
  .form {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    width: var(--form-width);
    transition: opacity 140ms ease;
  }

  .form.is-loading {
    opacity: 0.5;
  }

  .form-title {
    margin: 0;
    font-size: var(--size-xl);
    font-weight: var(--weight-semibold);
  }

  .form-body {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
  }

  .form-honeypot {
    position: absolute;
    left: -9999px;
    opacity: 0;
    height: 0;
    width: 0;
    overflow: hidden;
  }

  .form-actions {
    display: flex;
    justify-content: flex-start;
    gap: var(--space-3);
  }

  .form-wrapper {
    display: grid;
    gap: var(--space-4);
  }

  .form-alerts {
    display: grid;
    gap: var(--space-3);
  }

  .form-alert {
    width: 100%;
  }

  .form-field-block {
    display: grid;
    gap: var(--space-2);
  }

  .form-radio-group {
    display: grid;
    gap: var(--space-2);
  }

  .form-alert-link {
    font: inherit;
    color: var(--color-fg);
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 0.25rem;
    padding: 0.2rem 0.55rem;
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    text-align: left;
    text-decoration: none;
    font-size: var(--size-sm);
    line-height: 1.3;
    cursor: pointer;
    transition:
      background 120ms ease,
      border-color 120ms ease,
      transform 120ms ease;
  }

  .form-alert-link:hover {
    background: var(--color-surface);
    border-color: var(--color-fg);
  }

  .form-alert-link:active {
    transform: translateY(1px);
  }

  .form-alert-link:focus-visible {
    outline: 2px solid var(--color-focus);
    outline-offset: 2px;
  }

  .form-submit-spinner {
    width: 1em;
    height: 1em;
    border: 0.14em solid currentColor;
    border-right-color: transparent;
    border-radius: 50%;
    display: inline-block;
    animation: form-submit-spin 650ms linear infinite;
  }

  .form-visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @keyframes form-submit-spin {
    to {
      transform: rotate(360deg);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .form-submit-spinner {
      animation: none;
    }
  }

  .is-hidden {
    display: none !important;
  }
</style>
